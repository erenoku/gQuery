import { c as create_ssr_component } from "../../chunks/index-5b047f55.js";
import { marked } from "marked";
import Prism from "prismjs";
var source = "#### Not like jQuery. A different kind of GraphQL Client for Svelte Kit\n\n## How to use\n\n### 0. Install\n\n```shell\nnpm install --save @leveluptuts/g-query graphql-tag\n```\n\n### 1. Initialize G\n\n```javascript\n// src/lib/config/g.ts\n\nexport const g = new GFetch({\n	path: 'https://yourapiurl.com/graphql' //whatever your api url is here\n	// More config options coming, for now this is just path to your graphql api\n});\n```\n\n> \u{1F440}: This expects that you have a Graphql API already running. This can be any valid graphql api url.\n\n### 2. Add GraphQL Codegen Plugin to Svelte Kit\n\n```javascript\n// svelte.config.js\n\nimport gQueryCodegen from '@leveluptuts/g-query/codegen'\n\n...\nvite: {\n	plugins: [\n		gQueryCodegen({\n			// Required\n			// schema: 'http://localhost:3001/graphql' // this can also be a url to a graphql api\n			schema: './src/lib/graphql/schema.graphql', // path to schema, schema is required\n			out: './src/lib/graphql', // Where you want the general schema types to output\n			gPath: '$lib/config/g' // Path to g, created in step 1.\n			// Optional\n			debug: false  // boolean, this adds logging for gq files deleted and on codegen\n		})\n	],\n}\n...\n```\n\n### 3. Add .graphql files\n\n```graphql\n// UserQueries.graphql\n\nquery currentUser {\n	user {\n		_id\n	}\n}\n```\n\n### 4. Use it\n\nRun your dev process. Because gQuery uses a plugin to control the codegen, it will remove all .gq files then regenerate anytime there is a change to .graphql files. The codegen will find the file and spit out a file next to it. Named\n\n```\nFileName.gq.ts\n```\n\nUsing the above code, it would output\n\n```\nUserQueries.gq.ts\n```\n\nThis also gives us a \"get\" function for queries based on the query name. ie \"getUser\" for the above.\n\n```html\n<script context=\"module\" lang=\"ts\">\n	// The generated function that fetches and caches\n	import { getCurrentUser } from './UserQueries.gq';\n\n	export async function load({ fetch }) {\n		// Runs the cache/fetch function populating $currentUser before use.\n		await getCurrentUser({\n			variables: { limit: 0 },\n			fetch // Don't forget to pass fetch for ssr\n		});\n		return {};\n	}\n<\/script>\n\n<script lang=\"ts\">\n	// Cache becomes populated with data available for SSR\n	import { user } from './UserQueries.gq';\n\n	// $: console.log($user.user) //data available for ssr\n<\/script>\n```\n\n---\n\n## Examples\n\nAll of these examples assume a successful codegen run.\n\n### Query\n\n```html\n<script context=\"module\" lang=\"ts\">\n	// The generated function that fetches and caches\n	import { getCurrentUser } from './UserQueries.gq';\n\n	export async function load({ fetch }) {\n		// Runs the cache/fetch function populating $gCache before use.\n		await getCurrentUser({\n			variables: { limit: 0 },\n			fetch\n		});\n		return {};\n	}\n<\/script>\n\n<script lang=\"ts\">\n	// Cache becomes populated with data available for SSR\n	import { currenUser } from './UserQueries.gq';\n\n	// data available for ssr\n	// correctly ts typed and all\n	// $: console.log($currentUser.user) //data available for ssr\n<\/script>\n```\n\n### Mutation\n\n```graphql\n// UserQueries.graphql\n\nmutation makeUserAdmin($_id: ID!) {\n  makeUserAdmin(_id: $_id) {\n	  _id\n	  userName\n  }\n}\n```\n\n```html\n<script lang=\"ts\">\n	// The generated function that hits mutation\n	import { makeUserAdmin } from './UserQueries.gq';\n\n	async function makeAdmin() {\n		// Runs the cache/fetch function populating $gCache before use.\n		const { makeUserAdmin } = await makeUserAdmin({\n			variables: { _id: 'someCoolUsersId' },\n			fetch\n		});\n		// Want to update the cache?\n		// All gQuery objects are writable stores so you can just update like this\n		$currentUser.user = makeUserAdmin;\n		// OR\n		// You can just re-call the original query\n		// await getCurrentUser()\n	}\n<\/script>\n\n<button on:click=\"{makeAdmin}\">Make Cool User Admin</button>\n```\n\n### Subscription\n\nNot available yet, but should be fairly trivial with the current API, I just don't use them much, so I haven't invested the time. This code is well documented, so feel free to submit a PR.\n\n---\n\n## Dev Tools\n\nWe have some really neat dev tools available for gQuery via\n\n```shell\n@leveluptuts/svelte-toy\n```\n\nThese dev tools live in your project and can easily be added by making a new component. You can name it whatever you would like.\n\n```html\n// DevTools.svelte\n\n<script lang=\"ts\">\n	import { getStores } from '@leveluptuts/g-query';\n	import { Toy } from '@leveluptuts/svelte-toy'; // npm install --save @leveluptuts/svelte-toy\n\n	const modules = import.meta.globEager('./**/*.gq.ts'); // finds all gq.ts files in the current directory and subdirectories\n	let stores = getStores(modules);\n<\/script>\n\n<Toy register=\"{stores}\" />\n```\n\nThen you can use them by adding to your project easily. We hide ours in production and you probably should as well.\n\n```html\n<!-- \u{1F440} isDevelopment isn't something that exists without you making it. -->\n{#if isDevelopment}\n<DevTools />\n{/if}\n```\n\n---\n\n## Codegen In Depth\n\nThis section isn't required to read, but if you are the curious type, this will give you some insight into how codegen plays a role in g-query and what our output looks like.\n\nWe use the wonderful https://www.graphql-code-generator.com/ as the basis for all of our codegen.\n\n### What is actually generated?\n\nHere is an example. In this example we have a file AdminTags.graphql that contains 1 query and 1 mutations\n\nAdminTags.graphql\n\n```graphql\nquery adminTags {\n	tags {\n		_id\n		name\n	}\n}\n\nmutation deleteTag($_id: ID!) {\n	deleteTag(_id: $_id)\n}\n```\n\nFrom this, gQuery will generate a file named\n\n```shell\nAdminTags.gq.ts\n```\n\nThat will contain the following\n\n```javascript\nimport type * as Types from '../../graphql/types.gq';\nimport { writable } from 'svelte/store';\nimport { g } from '$lib/config/g';\nimport type { GFetchReturnWithErrors, GGetParameters } from '@leveluptuts/g-query';\nimport gql from 'graphql-tag';\n\nexport type AdminTagsQueryVariables = Types.Exact<{ [key: string]: never }>;\nexport type AdminTagsQuery = {\n	__typename?: 'Query';\n	tags?:\n		| Array<{ __typename?: 'Tag'; _id: string; name: string } | null | undefined>\n		| null\n		| undefined;\n};\nexport type DeleteTagMutationVariables = Types.Exact<{\n	_id: Types.Scalars['ID'];\n}>;\nexport type DeleteTagMutation = {\n	__typename?: 'Mutation';\n	deleteTag?: boolean | null | undefined;\n};\n\nexport const AdminTagsDoc = gql`\n	query adminTags {\n		tags {\n			_id\n			name\n		}\n	}\n`;\nexport const DeleteTagDoc = gql`\n	mutation deleteTag($_id: ID!) {\n		deleteTag(_id: $_id)\n	}\n`;\n\nexport const adminTags = writable<GFetchReturnWithErrors<AdminTagsQuery>>();\n\n// Cached\nexport async function getAdminTags(\n	{ fetch, variables }: GGetParameters<AdminTagsQueryVariables>,\n	options?: CacheFunctionOptions\n) {\n	const data = await g.fetch<AdminTagsQuery>({\n		queries: [{ query: AdminTagsDoc, variables }],\n		fetch\n	});\n	await adminTags.set({\n		...data,\n		errors: data?.errors,\n		status: 'LOADED'\n	});\n	return data;\n}\n\nexport const deleteTag = ({\n	variables\n}: SubscribeWrapperArgs<DeleteTagMutationVariables>): Promise<\n	GFetchReturnWithErrors<DeleteTagMutation>\n> =>\n	g.fetch<DeleteTagMutation>({\n		queries: [{ query: DeleteTagDoc, variables }],\n		fetch\n	});\n```\n\nYou can see from this, we have all the types we would need as well as our two usable functions and our Svelte writable.\n\n---\n\n## FAQ / WTF\n\n### Q? How tf do I update the cache?\n\nIt's a Svelte Writable Store. So after a mutation you can quickly and easily manually update the cache.\n\n```javascript\nimport { user, someMutation } from './UserQueries.gq';\n\n$user.user = null; // clears the cache object\n\n$user.user = await someMutation({ variables }); // if this returns the correct data\n```\n\n### Q? Can't you update the cache magically for me after a mutation?\n\nMaybe? If you want to be in charge of writing that bit, the door is open \u{1F63C}. My idea for the api would look something like this.\nThis isn't real code, but maybe a way to do it. Who knows, I'm open to anything.\n\n```javascript\nimport { user, someMutation } from './UserQueries.gq';\n\nawait someMutation({ variables, store: user });\n```\n\n### Q? How is this different than X, Y, Z library?\n\nWe're dogfooding / using this lib to build LevelUpTutorials.com. It's not intended to be perfect for every usecase, but effortless for ones like Level Up. There are similar libraries that have taken inspiration from gQuery, but only on gQuery. Check out our API and if it looks nice to you, give it a try. We plan on keeping this thing lightweight and effortless. Often imitated, never duplicated. Stay fresh.\n";
const Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
  marked.setOptions({
    highlight: (code, lang) => {
      if (Prism.languages[lang])
        return Prism.highlight(code, Prism.languages[lang || "markup"], lang);
      return code;
    }
  });
  return `<div class="${"markdown-render"}"><!-- HTML_TAG_START -->${marked(source)}<!-- HTML_TAG_END --></div>`;
});
export { Routes as default };
